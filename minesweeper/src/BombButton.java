/************************************************************//* A button class for a minesweeper game.                   *//* The button can hold a bomb or be blank. A regular click  *//* exposes the bomb, or displays a count of the number      *//* of neighbors, then disables the button. A special click  *//* will rotate marking the bomb as flagged, questionable or *//* normal without setting off the bomb.                     *//* A list of neighbors can be supplied.                     *//************************************************************/import javax.swing.*;import java.awt.Color;import java.awt.Insets;import java.util.List;public class BombButton extends JButton {	/* value displayed by the button. Will change if */	/* we move away from text. */	private static final String STATE_EMPTY = " ";	private static final String STATE_BOMB = "B";	private static final String STATE_FLAGGED = "F";	private static final String STATE_QUESTION = "?";	/* the dimensions of the button */	public static final int bombSizeX = 15;	public static final int bombSizeY = 15;	private boolean hasBomb = false;	/* Since a disabled button doesn't have an appropriate text */	/* color, we leave the button enabled, keep track of the */	/* state ourselves, and throw away any mouse clicks once */	/* the button is disabled (that is, has been left clicked) */	private boolean wasClicked = false;	private int neighborBombs = 0;	/* a list of adjacent neighbors */	private List<BombButton> neighbors;	/* right mouse click alternates between these states */	private int rotationStateIndex = 0;	/* A convenience class to keep all information about */	/* the button's rotation state in one place. */	private class RotationState {		String state;		Color color;		RotationState(String inState, Color inColor) {			state = inState;			color = inColor;		}	};	private RotationState[] clickRotation = {			new RotationState(STATE_EMPTY, Color.lightGray),			new RotationState(STATE_FLAGGED, Color.red),			new RotationState(STATE_QUESTION, Color.white) };	/* The button can display the number of its neighbors. */	/* Each of the possible 8 total counts displays in a */	/* different color. */	private static Color[] bombCountColors = { Color.white, Color.green, Color.blue,			Color.yellow, Color.orange, Color.darkGray, Color.magenta,			Color.cyan, Color.pink };		private static Color BOMB_COLOR = Color.red;	/********************************************************/	/* All bomb buttons start out empty, with no neighbors. */	/* Neighbors and bombs can be added later since when */	/* the button is being created the caller may not have */	/* created the neighbors yet. */	/********************************************************/	public BombButton() {		super(STATE_EMPTY);		setSize(bombSizeX, bombSizeY);		// A bit of a kludge. If the insets aren't zero the		// text can't be displayed so shows as "..."		setMargin(new Insets(0, 0, 0, 0));	}	/****************************************************/	/* Set the current draw state of the button. */	/* A convenience routine for paint. */	/****************************************************/	public void setDrawState() {		// no click yet so we're rotating		if (wasClicked == false) {			setText(clickRotation[rotationStateIndex].state);			setForeground(clickRotation[rotationStateIndex].color);			return;		}		if (hasBomb == true) {			setText(STATE_BOMB);			setBackground(BOMB_COLOR);			return;		}		setForeground(bombCountColors[neighborBombs]);		// empty squares blank, not a zero		if (neighborBombs == 0) {			setText(STATE_EMPTY);			setBackground(bombCountColors[neighborBombs]);			return;		}		setText("" + neighborBombs);	}	/********************************************************************/	/* Handle marking of potential bombs, that is, right mouse clicks */	/********************************************************************/	public void cycleState() {		if (wasClicked == true) {			setDrawState();			return;		}		rotationStateIndex = (rotationStateIndex + 1) % clickRotation.length;		setDrawState();	}	/********************************************************************/	/* Handle normal mouse clicks. Stepping on a bomb is a bad thing. */	/********************************************************************/	public void doNormalClick() {		if (wasClicked == true) {			return;		}		wasClicked = true;		if (hasBomb == true) {			setText(STATE_BOMB);			setDrawState();			return;		}				neighborBombs = countBombs(neighbors);		if (neighborBombs == 0) {			awakenEnabledNeighbors(neighbors);		}		setDrawState();	}	/************************************************/	/* Awaken any neighbors that are still enabled */	/* by simulating a user click. */	/************************************************/	private void awakenEnabledNeighbors(List<BombButton> neighbors) {		for (BombButton aButton : neighbors) {			if (aButton.wasClicked == false) {				aButton.doNormalClick();			}		}	}	/********************************************/	/* Count the number of neighboring bombs. */	/* The list of neighbors must have been */	/* previously provided. */	/********************************************/	private int countBombs(List<BombButton> neighbors) {		int totalBombs = 0;		for (BombButton aButton : neighbors) {			if (aButton.hasBomb())				totalBombs++;		}		return totalBombs;	}	/****************************************************/	/* Setter and getter for this button's bomb state. */	/****************************************************/	public void setBomb() {		hasBomb = true;	}	public boolean hasBomb() {		return hasBomb;	}	/********************************/	/* Acquire a list of neighbors */	/********************************/	public void setNeighbors(List<BombButton> inNeighbors) {		neighbors = inNeighbors;	}}